"""Type stubs for serilux package."""

from typing import Any, Callable, Dict, List, Optional, Type, TypeVar, Union

from serilux.exceptions import (
    CallableError,
    CircularReferenceError,
    ClassNotFoundError,
    DepthLimitError,
    DeserializationError,
    InvalidFieldError,
    SeriluxError,
    SerializationError,
    UnknownFieldError,
    ValidationError,
)

class Serializable:
    """Base class for serializable objects."""
    fields_to_serialize: List[str]
    def __init__(self) -> None: ...
    def add_serializable_fields(self, fields: List[str]) -> None: ...
    def remove_serializable_fields(self, fields: List[str]) -> None: ...
    def serialize(
        self, max_depth: int = ..., _current_depth: int = ...
    ) -> Dict[str, Any]: ...
    def deserialize(
        self, data: Dict[str, Any], strict: bool = ..., registry: Optional[Any] = ...
    ) -> None: ...

class SerializableRegistry:
    """Registry for serializable classes."""
    registry: Dict[str, type]
    @classmethod
    def register_class(cls, class_name: str, class_ref: type) -> None: ...
    @classmethod
    def get_class(cls, class_name: str) -> Optional[type]: ...

class ObjectRegistry:
    """Registry for object instances during deserialization."""
    def __init__(self) -> None: ...
    def register(self, obj: Any, object_id: Optional[str] = None) -> None: ...
    def find_by_id(self, object_id: str) -> Optional[Any]: ...
    def find_by_class_and_id(
        self, class_name: str, object_id: str
    ) -> Optional[Any]: ...
    def clear(self) -> None: ...
    def register_custom_lookup(
        self, class_name: str, lookup_func: Callable[..., Any]
    ) -> None: ...

def register_serializable(
    cls: Optional[type] = ...
) -> Union[Callable[[type], type], type]: ...

def check_serializable_constructability(obj: Any) -> bool: ...

def validate_serializable_tree(
    obj: Any, visited: Optional[set] = ...
) -> bool: ...

def serialize_callable(
    callable_obj: Callable[..., Any], owner: Optional[Any] = ...
) -> Optional[Dict[str, Any]]: ...

def serialize_callable_with_fallback(
    callable_obj: Callable[..., Any],
    owner: Optional[Any] = ...,
    fallback_to_expression: bool = ...,
) -> Optional[Dict[str, Any]]: ...

def deserialize_callable(
    callable_data: Dict[str, Any], registry: Optional[ObjectRegistry] = ...
) -> Optional[Callable[..., Any]]: ...

def deserialize_lambda_expression(
    expression_data: Dict[str, Any], default_param_name: str = ...
) -> Optional[Callable[..., Any]]: ...

def extract_callable_expression(func: Callable[..., Any]) -> Optional[str]: ...

__version__: str
__all__: List[str]
